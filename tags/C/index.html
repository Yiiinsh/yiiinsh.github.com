<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Yiiin</title>
  
    <link rel="icon" href="/assets/avatar.jpeg">
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/avatar.jpeg)">
        </div>
    </section>
    <section class='menu'>
        <div>Yiiin</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
    <header class='PageTitle'>
        <h1>{ C }</h1>
    </header>
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2018/02/02/Memory-Layout/">Memory Layout</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2018-02-02T01:31:22.000Z" itemprop="datePublished">
    2018-02-02
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/C/">C</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>今天做了一个简单的测试，简单地探究了一下GCC下的Memory Layout。</p>
<p>程序的运行环境如下：</p>
<pre><code>Linux indy2-login0 3.10.0-327.36.3.el7.x86_64 #1 SMP Mon Oct 24 16:09:20 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-11)
</code></pre><p>程序如下：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv){
  int i,j,k;
  double d;
  float f;
  void *p;

  struct fred {
     int a;
     short s;
     double d;
     double d2;
     short s2;
  }var;

  double a[30][30];
  int *pd2;
  double *pd;
  pd2 = (int*) malloc(sizeof(int));
  pd = (double*)malloc(sizeof(double));

  printf(&quot;i %d %016lx\n&quot;,sizeof(i),&amp;i);
  printf(&quot;j %d %016lx\n&quot;,sizeof(j),&amp;j);
  printf(&quot;k %d %016lx\n&quot;,sizeof(k),&amp;k);
  printf(&quot;d %d %016lx\n&quot;,sizeof(d),&amp;d);
  printf(&quot;f %d %016lx\n&quot;,sizeof(f),&amp;f);
  printf(&quot;p %d %016lx\n&quot;,sizeof(p),&amp;p);

  printf(&quot;var %d %016lx\n&quot;,sizeof(var),&amp;var);
  printf(&quot;var.a %d %016lx\n&quot;,sizeof(var.a),&amp;var.a);
  printf(&quot;var.s %d %016lx\n&quot;,sizeof(var.s),&amp;var.s);
  printf(&quot;var.d %d %016lx\n&quot;,sizeof(var.d),&amp;var.d);
  printf(&quot;var.s2 %d %016lx\n&quot;,sizeof(var.s2),&amp;var.s2);
  printf(&quot;var.d2 %d %016lx\n&quot;,sizeof(var.d2),&amp;var.d2);

  printf(&quot;a %d %016lx\n&quot;,sizeof(a),a);
  printf(&quot;pd %d %016lx\n&quot;,sizeof(pd),pd);
  printf(&quot;pd2 %d %016lx\n&quot;,sizeof(pd2),pd2);
}
</code></pre><p>采用gcc编译并运行这段程序，得到了如下的结果：</p>
<pre><code>i 4 00007fffffffdc7c
j 4 00007fffffffdc78
k 4 00007fffffffdc74
d 8 00007fffffffdc68
f 4 00007fffffffdc64
p 8 00007fffffffdc58
var 32 00007fffffffdc30
var.a 4 00007fffffffdc30
var.s 2 00007fffffffdc34
var.d 8 00007fffffffdc38
var.s2 2 00007fffffffdc48
var.d2 8 00007fffffffdc40
a 7200 00007fffffffc010
pd 8 0000000000602030
pd2 8 0000000000602010
</code></pre><p>可以看到，对于一个primitive，在该测试环境下，变量在stack上由高向低分配。对于一个结构体内部，所有的变量则在结构体对应的地址空间上由低向高顺序分配。</p>
<p>这里注意到，对于var这个由1个int，2个short，2个double组成的结构体，理论上，这个结构体应该占据24byte的空间，然而实际上var这个结构体占据了32byte。这是由于GCC下会对该程序进行一个内存对齐（alignment）。通常来说，内存总线以字（word， 4byte）为最小单位进行传输。为了避免传输的数据被截断，需要重新指向来获取数据所造成的额外的开销，GCC对这个程序进行了内存对齐的处理。变量s是一个short型变量，在该环境下占2byte。假设紧随其后的double变量d在内存上紧接着s存储，当数据传输过来时，由于以字为单位进行传输，变量d将会被截断，为了恢复变量d需要做额外的处理。因此，在此处s后面，GCC填充了2byte的占位字节，使其称为一个完整的word，而相应的d则紧随其后，在两个齐整的word下存储。这就是为什么var这个结构体使用了比理想状态下更多的空间。</p>
<p>下面我们对于代码进行小小的调整，我们修改var所对应的结构体，将s2变量的位置提升到s之下，其余部分不变：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv){
  int i,j,k;
  double d;
  float f;
  void *p;

  struct fred {
     int a;
     short s;
     short s2;
     double d;
     double d2;
  }var;

  double a[30][30];
  int *pd2;
  double *pd;
  pd2 = (int*) malloc(sizeof(int));
  pd = (double*)malloc(sizeof(double));

  printf(&quot;i %d %016lx\n&quot;,sizeof(i),&amp;i);
  printf(&quot;j %d %016lx\n&quot;,sizeof(j),&amp;j);
  printf(&quot;k %d %016lx\n&quot;,sizeof(k),&amp;k);
  printf(&quot;d %d %016lx\n&quot;,sizeof(d),&amp;d);
  printf(&quot;f %d %016lx\n&quot;,sizeof(f),&amp;f);
  printf(&quot;p %d %016lx\n&quot;,sizeof(p),&amp;p);

  printf(&quot;var %d %016lx\n&quot;,sizeof(var),&amp;var);
  printf(&quot;var.a %d %016lx\n&quot;,sizeof(var.a),&amp;var.a);
  printf(&quot;var.s %d %016lx\n&quot;,sizeof(var.s),&amp;var.s);
  printf(&quot;var.d %d %016lx\n&quot;,sizeof(var.d),&amp;var.d);
  printf(&quot;var.s2 %d %016lx\n&quot;,sizeof(var.s2),&amp;var.s2);
  printf(&quot;var.d2 %d %016lx\n&quot;,sizeof(var.d2),&amp;var.d2);

  printf(&quot;a %d %016lx\n&quot;,sizeof(a),a);
  printf(&quot;pd %d %016lx\n&quot;,sizeof(pd),pd);
  printf(&quot;pd2 %d %016lx\n&quot;,sizeof(pd2),pd2);
}
</code></pre><p>然后编译执行程序，我们得到的如下的结果：</p>
<pre><code>i 4 00007fffffffdc7c
j 4 00007fffffffdc78
k 4 00007fffffffdc74
d 8 00007fffffffdc68
f 4 00007fffffffdc64
p 8 00007fffffffdc58
var 24 00007fffffffdc40
var.a 4 00007fffffffdc40
var.s 2 00007fffffffdc44
var.d 8 00007fffffffdc48
var.s2 2 00007fffffffdc46
var.d2 8 00007fffffffdc50
a 7200 00007fffffffc020
pd 8 0000000000602030
pd2 8 0000000000602010
</code></pre><p>此处我们看到，结构体对象var与我们预想的一样，占用了24byte的空间。这是因为简单的重排，使两个short变量s与s1正好占据一个word，避免了各自的对齐从而减少了空间的开销。由此可见，对于C语言中的结构体，在GCC下所有的成员变量会以对应的顺序进行存储，对于无法整齐排列在内存中的变量，会进行内存对齐，通过填充空的占位字节使其占据完整的一个word。通过对于变量顺序的调整，可以减少程序中的内存的使用！</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2017/12/19/typedef-in-C/">typedef in C</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2017-12-19T01:19:18.000Z" itemprop="datePublished">
    2017-12-19
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/C/">C</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>笔者对C语言只是知道简单的使用方法，并不是非常精通。近日在Redis的 server.h 文件中发现了这样的代码：</p>
<pre><code>typedef void redisCommandProc(client *c);
struct redisCommand {
    char *name;
    redisCommandProc *proc;
    ......
};
</code></pre><p>对于此处的 typedef 语句感到较为迷惑。就以前所知，C语言中的 typedef 就是用于创建一个数据类型的别名的关键字。此处的 typedef 语句应该是一个函数指针类型的别名. 而在结构体redisCommand中的 proc成员应该就是一个指向函数的指针，该函数接受一个client指针作为参数，返回为空。</p>
<p>函数指针类型的别名在笔者印象中应该采用如下的方式声明：</p>
<pre><code>typdef type (*funcptr)(args...);
</code></pre><p>此处，假设需要声明一个函数指针，其参数为一个client指针，返回为空，那么应该如此声明：</p>
<pre><code>typedef void (*redisCommandProc)(client *c);
</code></pre><p>在Redis源码中的这个声明并没有显示将redisCommandProc声明成一个指针。那么这两种声明方式又有什么异同呢?于是笔者写了一个简单的测试：</p>
<pre><code>#include &lt;stdio.h&gt;

typedef void funca(char);
typedef void (*funcb)(char);

typedef struct {
    /* Get compiler error : funca_without_pointer declared as a function*/
    //funca funca_without_pointer;
    funca *funca_with_reference;
    funca *funca_without_reference;
    funcb funcb_with_reference;
    funcb funcb_without_reference;
} FuncCaller;

static void func(char);

int main(int argc, char** argv) {
    FuncCaller caller;
    caller.funca_with_reference = &amp;func;
    caller.funca_without_reference = func;
    fprintf(stdout, &quot;funca_with_reference %p, funca_without_reference %p\n&quot;, caller.funca_with_reference,   caller.funca_without_reference);
    fprintf(stdout, &quot;*funca_with_reference %p, *funca_without_reference %p\n&quot;,  *caller.funca_with_reference, *caller.funca_without_reference);

    caller.funcb_with_reference = &amp;func;
    caller.funcb_without_reference = func;
    fprintf(stdout, &quot;funcb_with_reference %p, funcb_without_reference %p\n&quot;, caller.funcb_with_reference,   caller.funcb_without_reference);
    fprintf(stdout, &quot;*funcb_with_reference %p, *funcb_without_reference %p\n&quot;,  *caller.funcb_with_reference, *caller.funcb_without_reference);

    fprintf(stdout, &quot;funca\n&quot;);
    caller.funca_with_reference(&apos;a&apos;);
    fprintf(stdout, &quot;funcb\n&quot;);
    caller.funcb_without_reference(&apos;b&apos;);

    fprintf(stdout, &quot;funca address%p\n&quot;, &amp;caller.funca_without_reference);
    fprintf(stdout, &quot;funcb address%p\n&quot;, &amp;caller.funcb_without_reference);
}

void func(char source) {
    fprintf(stdout, &quot;Come from %c\n&quot;, source);
}
</code></pre><p>此处采用的编译器信息为：</p>
<pre><code>Apple LLVM version 9.0.0 (clang-900.0.39.2)
Target: x86_64-apple-darwin17.3.0
</code></pre><p>获得了如下的输出：</p>
<pre><code>funca_with_reference 0x104f34e40, funca_without_reference 0x104f34e40
*funca_with_reference 0x104f34e40, *funca_without_reference     0x104f34e40
funcb_with_reference 0x104f34e40, funcb_without_reference   0x104f34e40
*funcb_with_reference 0x104f34e40, *funcb_without_reference     0x104f34e40
funca
Come from a
funcb
Come from b
funca address0x7ffeeaccb948
funcb address0x7ffeeaccb958
</code></pre><p>根据上述结果可以看出，本质上，Redis中的声明方式：</p>
<pre><code>typedef void redisCommandProc(client *c);
</code></pre><p>本质上是对函数类型的一个别名，而非对函数指针的一个别名。当使用的时候，需要使用 redisCommandProc * 来声明一个指向函数的指针 ，如果遗漏了指针声明，则会变成一个函数类型，将会产生编译时的错误。</p>
<p>对于C语言中的函数名与函数指针，本质上二者并没有差别，都是存储了指向该函数的地址。因此，以下的调用其实是一样的：</p>
<pre><code>func(&apos;a&apos;);
(*func)(&apos;a&apos;);
</code></pre><p>以上可以从 C99 Specification 中的 6.3.2.1.4 获得认证：</p>
<pre><code>a function designator with type &quot;function returning type&quot; is converted to an expression that has type &quot;pointer to function returning type&quot;
</code></pre>
      
    </div>
</article>

    </li>
  
</ul>



            <footer>
    <div>© 2018 - Yin </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>